<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chalme</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chalme.github.io/"/>
  <updated>2016-12-15T16:34:20.820Z</updated>
  <id>http://chalme.github.io/</id>
  
  <author>
    <name>Chalme</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hadoop 概念</title>
    <link href="http://chalme.github.io/2016/12/15/hadoop-concept/"/>
    <id>http://chalme.github.io/2016/12/15/hadoop-concept/</id>
    <published>2016-12-15T15:51:21.000Z</published>
    <updated>2016-12-15T16:34:20.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我们"><a href="#我们" class="headerlink" title="我们"></a>我们</h2><h2 id="我们-1"><a href="#我们-1" class="headerlink" title="我们"></a>我们</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;我们&quot;&gt;&lt;a href=&quot;#我们&quot; class=&quot;headerlink&quot; title=&quot;我们&quot;&gt;&lt;/a&gt;我们&lt;/h2&gt;&lt;h2 id=&quot;我们-1&quot;&gt;&lt;a href=&quot;#我们-1&quot; class=&quot;headerlink&quot; title=&quot;我们&quot;&gt;&lt;/a&gt;我们&lt;/h2&gt;
    
    </summary>
    
    
      <category term="hadoop" scheme="http://chalme.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>hexo br 问题</title>
    <link href="http://chalme.github.io/2016/12/14/hexo-breaks/"/>
    <id>http://chalme.github.io/2016/12/14/hexo-breaks/</id>
    <published>2016-12-14T09:44:10.000Z</published>
    <updated>2016-12-14T19:19:24.589Z</updated>
    
    <content type="html"><![CDATA[<p>这两天用vim编写博客，在vim编写时使用了换行符，而且在hexo中同样也会显示出来，困扰
了好久。按照markdown的语法来说这应该不会出现这个问题。</p>
<p>查阅了一些信息，hexo博客是由<code>hexo-renderer-marked</code>(package.json中含有)解析的，然
后找到这一个依赖源在博客目录下<code>node_modules/hexo-renderer-marked/</code>,修改文件
<code>index.js</code>找到 <code>breaks</code> 改为false。即可
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">hexo.config.marked = assign(&#123;</div><div class="line">  gfm: <span class="literal">true</span>,</div><div class="line">  pedantic: <span class="literal">false</span>,</div><div class="line">  sanitize: <span class="literal">false</span>,</div><div class="line">  tables: <span class="literal">true</span>,</div><div class="line">  breaks: <span class="literal">false</span>,</div><div class="line">  smartLists: <span class="literal">true</span>,</div><div class="line">  smartypants: <span class="literal">true</span></div><div class="line">&#125;, hexo.config.marked);</div></pre></td></tr></table></figure></p>
<p>参考网址: <a href="http://www.bleachlei.site/blog/2016/11/02/Hexo-br-%E8%BF%87%E5%A4%9A%E9%97%AE%E9%A2%98/" target="_blank" rel="external">链接
1</a>
<a href="http://ranler.github.io/2013/12/31/hexo-breaks/" target="_blank" rel="external">链接2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天用vim编写博客，在vim编写时使用了换行符，而且在hexo中同样也会显示出来，困扰
了好久。按照markdown的语法来说这应该不会出现这个问题。&lt;/p&gt;
&lt;p&gt;查阅了一些信息，hexo博客是由&lt;code&gt;hexo-renderer-marked&lt;/code&gt;(pa
    
    </summary>
    
    
      <category term="hexo" scheme="http://chalme.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>关于容器技术</title>
    <link href="http://chalme.github.io/2016/12/11/docker-container/"/>
    <id>http://chalme.github.io/2016/12/11/docker-container/</id>
    <published>2016-12-10T17:34:08.000Z</published>
    <updated>2016-12-15T16:36:47.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于容器技术"><a href="#关于容器技术" class="headerlink" title="关于容器技术"></a>关于容器技术</h2><blockquote>
<p><strong>容器定义</strong>
首先必须是一个相对独立的运行环境，在这一点上，有点类似虚拟机的概念，但又没有
虚拟机那样彻底。另外，在一个容器环境内，应该最小化其对外界的影响，比如不能在
容器中把host上的资源全部消耗掉，这就是资源控制。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>容器技术已经集成到了Linux内核中，已经被当作Linux内核原生提供的特性。</li>
<li><p>容器技术主要包括<code>Namespace</code>和<code>Cgroup</code>两个内核特性。</p>
<ol>
<li>Namespace又称命名空间，它主要做访问隔离。其原理是针对一类资源进行抽象，
并将其封装在一起提供给一个容器使用，对于这类资源，因
为每个容器都有自己的抽象，而它们彼此之间是不可见的，所以就可以
做到访问隔离。</li>
<li>Cgroup 是control group的简称，又称控制组，它主要是做资源控制。
其原理是将一组进程放在一个控制组里，通过给这个控制组分配指定的
可用资源，达到控制这一组进程可用资源的目的。</li>
</ol>
<p>实际上，Namespace和Cgroup并不是强相关的两种技术，用户可以根据需要单
独使用他们，比如单独使用Cgroup做资源管理，就是一种比较常见的做法。而
如果把他们应用到一起，在一个Namespace中的进程恰好又在一个Cgroup中，
那么这些进程就既有访问隔离，又有资源控制，符合容器的特性，这样就创建
了一个容器。</p>
</li>
</ul>
<h2 id="理解容器"><a href="#理解容器" class="headerlink" title="理解容器"></a>理解容器</h2><ul>
<li><p>容器的核心技术是 Cgroup + Namespace ，但光有这两个抽象的技术概念是无
  法组成容器。Linux 容器的最小组成，可以由以下公式来表示：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">容器 = cgroup + <span class="keyword">namespace</span> + rootfs + 容器引擎（用户态工具）</div></pre></td></tr></table></figure>
<p>  其各项功能分别是：</p>
<ul>
<li>Cgroup：资源控制。</li>
<li>Namespace： 访问控制。</li>
<li>rootfs：文件系统隔离。</li>
<li>容器引擎：生命周期控制。</li>
</ul>
</li>
<li><p>容器的创建原理。</p>
  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">代码一：</div><div class="line">pid = clone(<span class="function"><span class="keyword">fun</span>, <span class="title">stack</span></span>, flags, clone_arg);</div><div class="line">(<span class="symbol">flags:</span> CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET</div><div class="line">| CLONE_NEWipc | CLONE_NEWuts | ...)</div><div class="line"></div><div class="line">代码二：</div><div class="line">echo $pid &gt; <span class="regexp">/sys/fs</span><span class="regexp">/cgroup/cpu</span><span class="regexp">/tasks</span></div><div class="line">echo $pid &gt; /sys<span class="regexp">/fs/cgroup</span><span class="regexp">/cpuset/tasks</span></div><div class="line">echo $pid &gt; <span class="regexp">/sys/fs</span><span class="regexp">/cgroup/blkio</span><span class="regexp">/tasks</span></div><div class="line">echo $pid &gt; /sys<span class="regexp">/fs/cgroup</span><span class="regexp">/memory/tasks</span></div><div class="line">echo $pid &gt; <span class="regexp">/sys/fs</span><span class="regexp">/cgroup/devices</span><span class="regexp">/tasks</span></div><div class="line">echo $pid &gt; /sys<span class="regexp">/fs/cgroup</span><span class="regexp">/freezer/tasks</span></div><div class="line"></div><div class="line">代码三：</div><div class="line"><span class="function"><span class="keyword">fun</span>() &#123;</span></div><div class="line">    ...</div><div class="line">    <span class="title">pivot_root</span>(<span class="string">"path_of_rootfs/"</span>, path);</div><div class="line">    ...</div><div class="line">    exec(<span class="string">"/bin/bash"</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>代码一，通过clone系统调用，并传入各个Namespace对应的clone flag
，创建了一个新的子进程，该进程拥有自己的Namespace。根据以上代码
可知，该进程拥有自己的pid、mount、user、net、ipc、uts namespace
。</li>
<li>代码二，将代码一中的进程pid写入各个Cgroup子系统中，这样该进程就
可以受到相应Cgroup子系统的控制。</li>
<li><p>代码三，该fun函数由上面生成的新进程执行，在fun函数中，通过
pivot_root系统调用，使进程进入一个新的rootfs，之后通过exec系统
调用，在新的Namespace、Cgroup、 rootfs 中执行”/bin/bash”程序。</p>
<p>通过以上操作，成功地在一个“容器”中运行了一个bash程序。</p>
</li>
</ol>
</li>
</ul>
<h2 id="Cgroup-介绍"><a href="#Cgroup-介绍" class="headerlink" title="Cgroup 介绍"></a>Cgroup 介绍</h2><h3 id="Cgroup-是什么"><a href="#Cgroup-是什么" class="headerlink" title="Cgroup 是什么"></a>Cgroup 是什么</h3><p>Cgroup 是 control group 的简写，属于Linux内核提供的一个特性，用于限制和隔离一组
进程对系统资源的使用，也就是做资源QoS，这些资源主要包括CPU、内存、block I/O和网
络带宽。</p>
<ul>
<li>从实现的角度来看，Cgroup实现了一个通用的进程分组的框架，而不同资源的具体管理则
  是由各个Cgroup子系统实现的。截止到内核4.1版本，Cgroup中实现的子系统及其作用
  如下：<ol>
<li>devices：设备权限控制。</li>
<li>cpuset：分配指定的CPU和内存节点。</li>
<li>cpu：控制CPU占用率。</li>
<li>cpuacct：统计CPU使用情况。</li>
<li>memory：限制内存的使用上限。</li>
<li>freezer：冻结（暂停）Cgroup中的进程。</li>
<li>net_cls：配合tc（traffic controller）限制网络带宽。</li>
<li>net_prio：设置进程的网络流量优先级。</li>
<li>huge_tlb：限制HugeTLB的使用。</li>
<li>perf_event：允许Perf工具基于Cgroup分组做性能检测。</li>
</ol>
</li>
<li>在Cgroup出现之前，只能对一个进程做一些资源控制。</li>
</ul>
<h2 id="Namespace-介绍"><a href="#Namespace-介绍" class="headerlink" title="Namespace 介绍"></a>Namespace 介绍</h2><h3 id="Namespace-是什么"><a href="#Namespace-是什么" class="headerlink" title="Namespace 是什么"></a>Namespace 是什么</h3><p>Namespace 是将内核的全局资源做封装，使得每个Namespace都有一份独立的资源，因此不
同的进程在各自的Namespace内对同一种资源的使用不会互相干扰。</p>
<ul>
<li>目前Linux内核总共实现了6种Namespace:<ol>
<li>IPC: 隔离System V IPC和POSIX消息队列。</li>
<li>Network：隔离网络资源。</li>
<li>Mount：隔离文件系统挂载点。</li>
<li>PID：隔离进程ID。</li>
<li>UTS：隔离主机名和域名。</li>
<li>User：隔离用户ID和组ID。</li>
</ol>
</li>
</ul>
<h2 id="最后。。"><a href="#最后。。" class="headerlink" title="最后。。"></a>最后。。</h2><p>很失望目前不能继续下去。我读的这本书是<code>docker进阶与实践</code>，确实是进阶，之前没有了
解过docker，现在写的基本都是在摘抄书上的内容，摘抄并没有错，但是确实理解不是特别
深刻，过段时间，在读。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于容器技术&quot;&gt;&lt;a href=&quot;#关于容器技术&quot; class=&quot;headerlink&quot; title=&quot;关于容器技术&quot;&gt;&lt;/a&gt;关于容器技术&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;容器定义&lt;/strong&gt;
首先必须是一个相对独立的运行环境，在这一点上，有点类似虚拟机的概念，但又没有
虚拟机那样彻底。另外，在一个容器环境内，应该最小化其对外界的影响，比如不能在
容器中把host上的资源全部消耗掉，这就是资源控制。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://chalme.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>指针的详解</title>
    <link href="http://chalme.github.io/2016/09/12/pointer-c/"/>
    <id>http://chalme.github.io/2016/09/12/pointer-c/</id>
    <published>2016-09-12T01:24:54.000Z</published>
    <updated>2016-12-14T19:19:24.589Z</updated>
    
    <content type="html"><![CDATA[<p>对于指针的确我之前还没真正了解，一次面试暴露无遗。确实还是应该好好学习一下指针。
<a id="more"></a></p>
<p>今天看了一篇文章，确实还是挺详细的。 <a href="http://www.cnblogs.com/ggjucheng/archive/2011/12/13/2286391.html" target="_blank" rel="external">点此进入</a></p>
<blockquote>
<p>了解指针一般要清楚3点</p>
<ol>
<li>指针的类型</li>
<li>指针所指向的类型</li>
<li>指针的值</li>
</ol>
</blockquote>
<p>具体请看<a href="http://www.cnblogs.com/ggjucheng/archive/2011/12/13/2286391.html" target="_blank" rel="external">原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于指针的确我之前还没真正了解，一次面试暴露无遗。确实还是应该好好学习一下指针。
    
    </summary>
    
    
      <category term="c/c++" scheme="http://chalme.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>git配置多个ssh用户</title>
    <link href="http://chalme.github.io/2016/08/04/gitissue/"/>
    <id>http://chalme.github.io/2016/08/04/gitissue/</id>
    <published>2016-08-03T18:32:35.000Z</published>
    <updated>2016-12-14T19:19:24.589Z</updated>
    
    <content type="html"><![CDATA[<p>今天这是我写的第一篇博客，不知道在使用git中遇到过下面的问题 :</p>
<blockquote><p>自己配置了全局的用户信息，然后我们却有两个或两个之上 的git账号在不同的服务器上(比如
github, csdn),或者我们正在做两个以上项目(在github)需要配置不同ssh， 我们的用户信息却
不同, 但是我们却不能配置两个全局信息。为了使用ssh服务，避免每次都要输入用户密码，我们
还是要使用秘钥来配置。</p>
</blockquote>
<a id="more"></a>
<h2 id="其实这就是个坑"><a href="#其实这就是个坑" class="headerlink" title="其实这就是个坑"></a>其实这就是个坑</h2><p>当我们是新手时，每次看到教程都要配置全局的个人信息(user.name, user.email)，虽然它比较简单，但确实导致
了一些使用的问题。 切入正题，解决方案：</p>
<blockquote>
<p>我们不要使用使用全局的用户信息配置，改成在项目内部配置。
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">git config user.name <span class="string">"username"</span></div><div class="line">git config user.email <span class="string">"XXX@email.com"</span></div></pre></td></tr></table></figure></p>
<p>配置公钥时，需要在<code>~/.ssh</code>目录下添加一个 <code>config</code> 的文件,格式如下
<figure class="highlight crmsh"><table><tr><td class="code"><pre><div class="line">Host                         名称(自己决定，方便输入记忆的)</div><div class="line">HostName                     主机名</div><div class="line"><span class="keyword">User</span>                         <span class="title">登录的用户名</span></div><div class="line">IdentityFile                 私钥地址</div></pre></td></tr></table></figure></p>
<p>例子
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#github                    <span class="comment">"注释</span></div><div class="line">Host github.<span class="keyword">com</span>            <span class="comment">" 简称</span></div><div class="line">HostName github.<span class="keyword">com</span>        <span class="comment">" 服务器地址</span></div><div class="line">User chalme                <span class="comment">" 用户名</span></div><div class="line">IdentityFile ~/.ssh/id_rsa <span class="comment">" 公钥地址</span></div><div class="line"></div><div class="line">Host code.csdn.net</div><div class="line">HostName code.csdn.net</div><div class="line">User chalme</div><div class="line">IdentityFile ~/.ssh/id_rsa_csdn</div><div class="line"></div><div class="line">Host A</div><div class="line">HostName github.<span class="keyword">com</span></div><div class="line">User B</div><div class="line">IdentityFile ~/.ssh/id_rsa_csdn</div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天这是我写的第一篇博客，不知道在使用git中遇到过下面的问题 :&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;自己配置了全局的用户信息，然后我们却有两个或两个之上 的git账号在不同的服务器上(比如
github, csdn),或者我们正在做两个以上项目(在github)需要配置不同ssh， 我们的用户信息却
不同, 但是我们却不能配置两个全局信息。为了使用ssh服务，避免每次都要输入用户密码，我们
还是要使用秘钥来配置。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://chalme.github.io/tags/git/"/>
    
  </entry>
  
</feed>
